{
  "name": "Object Adujsments methods",
  "type": "map",
  "code": "var createScene = async function () {\n    // This creates a basic Babylon Scene object (non-mesh)\n    var scene = new BABYLON.Scene(engine);\n    const server = \"external-import/server1/\";\n\n    const screen = {};\n    // determine the size of the viewport minus the gutter based on the current window width\n    function setViewportSize() {\n        screen.width = engine.getRenderWidth();\n        screen.height = engine.getRenderHeight();\n        screen.ratio = screen.width / screen.height;\n        camera.productWidth = 0.6;\n        camera.product.viewport = new BABYLON.Viewport(1.0 - camera.productWidth, 0.0, camera.productWidth, 1.0);\n    }\n\n    function updateViewportSize() {\n        screen.width = engine.getRenderWidth();\n        screen.height = engine.getRenderHeight();\n        screen.ratio = screen.width / screen.height;\n        // resize content buttons based on screen size\n        for (let control of gui.contentButtons) {\n            if (screen.ratio < 0.6) {\n                let calculatedWidth = ((screen.width * gui.layoutGrid.getColumnDefinition(0)._value) / gui.contentButtonsGrid.columnCount) * 0.7;\n                control.width = Math.floor(calculatedWidth).toString() + \"px\";\n            }\n            else {\n                let calculatedHeight = ((screen.height * gui.layoutGrid.getRowDefinition(1)._value)/ gui.contentButtonsGrid.rowCount) * 0.7;\n                control.height = Math.floor(calculatedHeight).toString() + \"px\";\n            }\n        }\n        // resize layer buttons based on screen size\n        if (gui.buttons !== undefined) {\n            for (let control of gui.buttons) {\n                if (screen.ratio < 0.6 && control.name.split(\"_\")[2] !== \"selectButton\") {\n                    if (control._children[0] !== undefined) {\n                        control._children[0].height = \"95%\";\n                    }\n                    let calculatedWidth = ((screen.width * gui.layoutGrid.getColumnDefinition(0)._value) * gui.layerUiGrid[0].getColumnDefinition(1)._value);\n                    control.width = Math.floor(calculatedWidth).toString() + \"px\";\n                }\n                else {\n                    if (control._children[0] !== undefined) {\n                        control._children[0].height = \"60%\";\n                    }\n                    let calculatedHeight = ((screen.height * gui.layoutGrid.getRowDefinition(0)._value) * gui.layersGrid.getRowDefinition(1)._value);\n                    control.height = Math.floor(calculatedHeight).toString() + \"px\";\n                }\n            }\n        }\n        // resize layer grid width based on screen size for button position\n        if (gui.layerUiGrid !== undefined) {\n            for (let layer of gui.layerUiGrid) {\n                if (screen.ratio < 0.6) {\n                    layer.setColumnDefinition(1, 0.18, false);\n                    layer.setColumnDefinition(2, 0.18, false);\n                    layer.setColumnDefinition(3, 0.18, false);\n                }\n                else {\n                    layer.setColumnDefinition(1, 60, true);\n                    layer.setColumnDefinition(2, 60, true);\n                    layer.setColumnDefinition(3, 60, true);\n                }\n            }\n        }\n        // resize viewport based on screen size\n        if (gui.layoutGrid !== undefined) {\n            if (screen.ratio < 0.9) {\n                gui.layoutGrid.setColumnDefinition(0, 0.5, false);\n                gui.layoutGrid.setColumnDefinition(1, 0.5, false);\n                camera.productWidth = 0.5;\n            }\n            else if (screen.ratio > 0.9 && screen.ratio < 1.5) {\n                gui.layoutGrid.setColumnDefinition(0, 0.4, false);\n                gui.layoutGrid.setColumnDefinition(1, 0.6, false);\n                camera.productWidth = 0.6;\n            }\n            else {\n                gui.layoutGrid.setColumnDefinition(0, 0.25, false);\n                gui.layoutGrid.setColumnDefinition(1, 0.75, false);\n                camera.productWidth = 0.75;\n            }\n            camera.product.viewport.x = 1.0 - camera.productWidth;\n            camera.product.viewport.width = camera.productWidth;\n        }\n    }\n\n    // create camera and lights for scene\n    const lights = {};\n    const env = {};\n    const camera = {};\n    const mask = {\n        gui : 0x01000000,\n        product: 0x10000000,\n    };\n    async function initScene() {\n        // color of scene when no skybox present\n        scene.clearColor = BABYLON.Color3.FromInts(30, 30, 35);\n\n        // standard ArcRotate camera\n        camera.product = new BABYLON.ArcRotateCamera(\"productCamera\", -2.183, Math.PI/2, 1.3, new BABYLON.Vector3(0.0, 0.0, 0.0), scene);\n        camera.product.minZ = 0.1;\n        camera.product.lowerRadiusLimit = 0.55;\n        camera.product.upperRadiusLimit = 3.0;\n        camera.product.wheelDeltaPercentage = 0.1;\n        camera.product.panningAxis = new BABYLON.Vector3(0.0, 0.0, 0.0);\n        camera.product.attachControl(canvas, true);\n        camera.product.layerMask = mask.product;\n\n        camera.gui = new BABYLON.ArcRotateCamera(\"guiCamera\", 0.0, 0.0, 1.0, new BABYLON.Vector3(0.0, 0.0, 0.0), scene);\n        camera.gui.layerMask = mask.gui;\n        setViewportSize();\n        engine.onResizeObservable.add(updateViewportSize);\n\n        scene.activeCameras.push(camera.product);\n        scene.activeCameras.push(camera.gui);\n\n        // add in IBL with linked environment\n        env.lighting = BABYLON.CubeTexture.CreateFromPrefilteredData(server + \"studio.env\", scene);\n        env.lighting.name = \"studioIBL\";\n        env.lighting.gammaSpace = false;\n        env.lighting.rotationY = 3.14;\n        scene.environmentTexture = env.lighting;\n        scene.environmentIntensity = 1.0;\n\n        // directional light needed for shadows\n        lights.dirLight = new BABYLON.DirectionalLight(\"dirLight\", new BABYLON.Vector3(0.45, -0.34, -0.83), scene);\n        lights.dirLight.position = new BABYLON.Vector3(0, 3, 5);\n        lights.dirLight.intensity = 1;\n    }\n\n    const assets = {\n        manager : new BABYLON.AssetsManager(scene),\n        graphics : []\n    }\n    const imprintWidth = 683;\n    const imprintHeight = 2048;\n    const imprint = {\n        texture : new BABYLON.DynamicTexture(\"decalTex\", {width: imprintWidth, height: imprintHeight}, scene),\n        defaultBackground : new BABYLON.Color4(1.0, 0.0, 0.0, 1.0).toHexString(),\n        graphics : []\n    };\n    imprint.context = imprint.texture.getContext();\n\n    const maxLayers = 5;\n    const layers = [];\n    async function loadAssets() {\n        // mesh tasks\n        assets.skateboard = assets.manager.addMeshTask(\"load skateboard\", \"\", server + \"skateboard_mesh.glb\")\n\n        // image tasks\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Babylon Logo\", server + \"babylonLogo.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Flame Skull\", server + \"flameSkull.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Blue Character\", server + \"cartoonHead_blue.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Orange Character\", server + \"cartoonHead_orange.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Purple Character\", server + \"cartoonHead_purple.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Pony\", server + \"pony.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Rays\", server + \"rays.png\"));\n        assets.graphics.push(assets.manager.addImageTask(\"load image_Waves\", server + \"waves.png\"));\n        assets.moveUpIcon = assets.manager.addImageTask(\"load move up icon\", server + \"upArrowCircle.svg\");\n        assets.moveDownIcon = assets.manager.addImageTask(\"load move up icon\", server + \"downArrowCircle.svg\");\n        assets.cancelIcon = assets.manager.addImageTask(\"load move up icon\", server + \"cancelCircle.svg\");\n        assets.addIcon = assets.manager.addImageTask(\"load move up icon\", server + \"addCircle.svg\");\n        assets.colors = [\n            \"Azure\",\n            \"Black\",\n            \"DarkGray\",\n            \"DimGray\",\n            \"Red\",\n            \"FireBrick\",\n            \"DeepPink\",\n            \"OrangeRed\",\n            \"Orange\",\n            \"Gold\",\n            \"Yellow\",\n            \"RoyalBlue\",\n            \"CornflowerBlue\",\n            \"DeepSkyBlue\",\n            \"DarkGreen\",\n            \"ForestGreen\",\n            \"GreenYellow\",\n            \"RebeccaPurple\",\n            \"DarkViolet\",\n            \"MediumPurple\",\n        ]\n\n        // text tasks\n        assets.decalShaderText = assets.manager.addTextFileTask(\"load decal node material\", server + \"decalShader.json\");\n\n        // call all loading tasks\n        assets.manager.load();\n\n        // task error handling\n        assets.manager.onTaskErrorObservable.add((task) => {\n            console.log(\"Error loading task: \" + task.name);\n            console.log(task.errorObject.message, task.errorObject.exception);\n        });\n\n        // wait for all tasks to complete\n        assets.manager.onFinish = (tasks) => {\n            console.log(\"All tasks complete!\", tasks);\n\n            // set graphic properties array\n            for (let loaded of assets.graphics) {\n                imprint.graphics.push({\n                    image : loaded.image,\n                    ratio : loaded.image.width / loaded.image.height,\n                    size : loaded.image.width,\n                    name : loaded.name.split(\"_\")[1]\n                });\n            }\n\n            // skateboard root\n            assets.skateboardRoot = assets.skateboard.loadedMeshes[0];\n            assets.skateboardRoot.name = \"skateboardRoot\";\n            assets.skateboardMesh = assets.skateboard.loadedMeshes[1];\n            for (let child of assets.skateboard.loadedMeshes) {\n                child.layerMask = mask.product;\n            }\n\n            // parse loaded node material to json\n            assets.decalShaderJson = JSON.parse(assets.decalShaderText.text);\n\n            // set up layer data array\n            for (let i = 0; i < maxLayers; i++) {\n                layers.push({\n                    name: undefined,\n                    graphic : undefined,\n                    rectangle: false,\n                    ratio : 1.0,\n                    horizontal : 0.0,\n                    vertical : 0.0,\n                    size : 512,\n                    rotation : 0.0,\n                    width: 1.0,\n                    height : 1.0,\n                    fillStyle : new BABYLON.Color4(0.0, 0.0, 0.0, 0.0).toHexString()\n                });\n            }\n\n            // create materials for scene meshes\n            createMaterials();\n            createGUI();\n            createContentButtons();\n        }\n    }\n\n    // prevent updating dynamic texture when setting slider values while changing layers\n    let activeUpdate = true;\n    // update dynamic texture\n    async function updateimprint() {\n        // clear imprint\n        imprint.context.clearRect(0, 0, imprintWidth, imprintHeight);\n        // only update dynamic texture if the user is actively changing a GUI slider\n        if (activeUpdate) {\n            for (let thisLayer of layers) {\n                if (thisLayer.graphic !== undefined) {\n                    // save context\n                    imprint.context.save();\n    \n                    // set rotation center accounting for manual offset\n                    const graphicU = thisLayer.horizontal * imprintWidth * 0.5;\n                    const graphicV = thisLayer.vertical * imprintHeight * -0.5;\n                    imprint.context.translate(imprintWidth * 0.5 + graphicU, imprintHeight * 0.5 + graphicV);\n    \n                    // determine position of graphic on texture in pixels\n                    const left = thisLayer.size * thisLayer.ratio * -0.5;\n                    const top = thisLayer.size * -0.5;\n    \n                    // rotate layer and draw graphic\n                    imprint.context.rotate(thisLayer.rotation);\n                    imprint.context.drawImage(thisLayer.graphic, left, top, thisLayer.ratio * thisLayer.size, thisLayer.size);\n    \n                    // restore context pre-rotation\n                    imprint.context.restore();\n                }\n                else if (thisLayer.rectangle) {\n                    // save context\n                    imprint.context.save();\n    \n                    // set bounds of rectangle\n                    const left = (1 - thisLayer.width) * 0.5 * imprintWidth;\n                    const top = (1- thisLayer.height) * 0.5 * imprintHeight;\n                    const width = thisLayer.width * imprintWidth;\n                    const height = thisLayer.height * imprintHeight;\n    \n                    const offsetU = thisLayer.horizontal * imprintWidth * 0.5;\n                    const offsetV = thisLayer.vertical * imprintHeight * -0.5;\n    \n                    // translate center for rotation\n                    const rectangleU = width * 0.5 + left;\n                    const rectangleV = height * 0.5 + top;\n                    imprint.context.translate(rectangleU + offsetU, rectangleV + offsetV);\n    \n                    // rotate context before drawing\n                    imprint.context.rotate(thisLayer.rotation);\n    \n                    // draw rectangle\n                    imprint.context.fillStyle = thisLayer.fillStyle;\n                    imprint.context.fillRect(-width * 0.5, -height * 0.5, width, height);\n    \n                    // restore context\n                    imprint.context.restore();\n                }\n                else {\n                    continue;\n                }\n            }\n            // update texture\n            imprint.texture.update();\n        }\n    }\n\n    // create materials for scene meshes\n    // ignore textures embedded in shader when loading\n    BABYLON.NodeMaterial.IgnoreTexturesAtLoadTime = true;\n    const meshesMats = {};\n    async function createMaterials() {\n        meshesMats.skateboard = BABYLON.NodeMaterial.Parse(assets.decalShaderJson, scene);\n        meshesMats.skateboard.name = \"skateboardDecalMat\";\n\n        // create default dynamic texture\n        updateimprint();\n\n        // get texture blocks and assign PBR textures from loaded mesh and dynamic texture\n        meshesMats.skateboard.getBlockByName(\"decalTex\").texture = imprint.texture;\n        meshesMats.skateboard.getBlockByName(\"baseColorTex\").texture = assets.skateboardMesh.material.albedoTexture;\n        meshesMats.skateboard.getBlockByName(\"ormTex\").texture = assets.skateboardMesh.material.metallicTexture;\n        meshesMats.skateboard.getBlockByName(\"normalTex\").texture = assets.skateboardMesh.material.bumpTexture;\n        assets.skateboardMesh.material.dispose();\n        assets.skateboardMesh.material = meshesMats.skateboard;\n    }\n\n    // create GUI AdvancedDynamicTexture\n    const gui = {\n        texture : await BABYLON.GUI.AdvancedDynamicTexture.ParseFromFileAsync(server + \"imprintCustomizationGui.json\"),\n        contentButtons : []\n    };\n    // dynamically create content buttons \n    function createContentButtons() {\n        let lastButton = 0;\n        // create color buttons from colors array\n        for (let i = 0; i < assets.colors.length; i++) {\n            const button = new BABYLON.GUI.Button(assets.colors[i]);\n            button.fixedRatio = 1.0;\n            button.thickness = 2;\n            button.background = assets.colors[i];\n            button.onPointerClickObservable.add(function() {\n                layers[currentLayer].name = button.name;\n                layers[currentLayer].fillStyle = button.name;\n                layers[currentLayer].rectangle = true;\n                layers[currentLayer].graphic = undefined;\n                layers[currentLayer].width = 1.0;\n                loadLayerContentUI(currentLayer);\n                updateLayerNames();\n                updateGUI(layers[currentLayer]);\n                showLayerControls();\n                updateimprint();\n            });\n            gui.contentButtonsGrid.addControl(button, Math.floor(i / 4), i % 4);\n            gui.contentButtons.push(button);\n            lastButton = i + 1;\n        }\n        // create graphic buttons from graphics array\n        for (let i = lastButton; i < assets.graphics.length + lastButton; i++) {\n            const button = BABYLON.GUI.Button.CreateImageOnlyButton(assets.graphics[i - lastButton].name.split(\"_\")[1], assets.graphics[i - lastButton].url);\n            button.image.width = 0.8;\n            button.image.height = 0.8;\n            button.image.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n            button.image.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;\n            button.fixedRatio = 1.0;\n            button.thickness = 2;\n            button.background = \"black\";\n            button.onPointerClickObservable.add(function() {\n                layers[currentLayer].name = button.name;\n                layers[currentLayer].fillStyle = undefined;\n                layers[currentLayer].rectangle = false;\n                for (let graphic of assets.graphics) {\n                    if (graphic.name.split(\"_\")[1] === button.name) {\n                        layers[currentLayer].graphic = graphic.image;\n                    }\n                }\n                loadLayerContentUI(currentLayer);\n                updateLayerNames();\n                updateGUI(layers[currentLayer]);\n                showLayerControls();\n                updateimprint();\n            });\n            gui.contentButtonsGrid.addControl(button, Math.floor(i / 4), i % 4);\n            gui.contentButtons.push(button);\n        }\n        updateViewportSize();\n    }\n    \n    // change visibility of GUI grids to show content buttons\n    let currentLayer = undefined;\n    function chooseContent() {\n        updateActiveLayer();\n        gui.slidersGrid.isVisible = false;\n        gui.contentButtonsGrid.isVisible = true;\n    }\n\n    // change visibility of GUI grids to show layer parameter sliders\n    function showLayerControls() {\n        updateActiveLayer();\n        gui.slidersGrid.isVisible = true;\n        gui.contentButtonsGrid.isVisible = false;\n    }\n    \n    // update GUI layer background color to highlight active layer\n    function updateActiveLayer() {\n        updateGUI(layers[currentLayer]);\n        for (let rect of gui.layerBG) {\n            if (parseInt(rect.name.split(\"_\")[1], 10) === currentLayer) {\n                rect.background = gui.highlightLayerColor;\n            }\n            else {\n                rect.background = gui.layerColor;\n            }\n        }\n    }\n\n    // update layers array to move layer parameters up or down one index position\n    function moveLayer(index, direction) {\n        const temp = layers[index];\n        if (direction === \"up\") {\n            layers[index] = layers[index - 1];\n            layers[index - 1] = temp;\n        }\n        else if (direction === \"down\") {\n            layers[index] = layers[index + 1];\n            layers[index + 1] = temp;\n        }\n        updateGUI(layers[currentLayer]);\n        updateimprint();\n        updateLayerNames();\n        gui.slidersGrid.isVisible = false;\n        gui.contentButtonsGrid.isVisible = false;\n    }\n\n    // update GUI layer names to match layers array\n    function updateLayerNames() {\n        for (let i=0; i < layers.length; i++) {\n            for (let target of gui.layerUiGrid) {\n                if (parseInt(target.name.split(\"_\")[1]) === i) {\n                    for (let control of target.getDescendants(false)) {\n                        if (control.name.split(\"_\")[2] === \"contentName\") {\n                            if (layers[i].name !== undefined)\n                            {\n                                loadLayerContentUI(i);\n                                control.text = layers[i].name;\n                            }  \n                            else {\n                                unloadLayerContentUI(i);\n                            }                  \n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // update layer to hide insert button and show layer action buttons when content selected for layer\n    function loadLayerContentUI(index) {\n        for (let button of gui.buttons) {\n            if (button.name.split(\"_\")[2] === \"insertButton\" && button.name.split(\"_\")[1] === index.toString()) {\n                button.isVisible = false;\n            }\n        }\n        for (let grid of gui.layerUiGrid) {\n            if (grid.name.split(\"_\")[1] === index.toString()) {\n                grid.isVisible = true;\n            }\n        }\n    }\n\n    // update layer to hide layer action buttons and show insert button when content deleted from layer\n    function unloadLayerContentUI(index) {\n        for (let button of gui.buttons) {\n            if (button.name.split(\"_\")[2] === \"insertButton\" && button.name.split(\"_\")[1] === index.toString()) {\n                button.isVisible = true;\n            }\n        }\n        for (let grid of gui.layerUiGrid) {\n            if (grid.name.split(\"_\")[1] === index.toString()) {\n                grid.isVisible = false;\n            }\n        }\n    }\n\n    // revert layer parameters in layers array to default values when content deleted from layer\n    function removeLayerGraphic(index) {\n        layers[index].name = undefined;\n        layers[index].graphic = undefined;\n        layers[index].rectangle = false;\n        layers[index].ratio = 1.0;\n        layers[index].horizontal = 0.0;\n        layers[index].vertical = 0.0;\n        layers[index].size = 512;\n        layers[index].rotation = 0.0;\n        layers[index].width = 1.0;\n        layers[index].height = 1.0;\n        layers[index].fillStyle = new BABYLON.Color4(0.0, 0.0, 0.0, 0.0).toHexString();\n        currentLayer = undefined;\n        updateActiveLayer();\n        gui.slidersGrid.isVisible = false;\n        gui.contentButtonsGrid.isVisible = false;\n        updateimprint();\n    }\n\n    // define GUI style parameters and actions for interactivity\n    gui.texture.layer.layerMask = mask.gui;\n    gui.layerColor = \"#381A1AFF\";\n    gui.highlightLayerColor = \"#e42d2dFF\";\n    gui.layerUiGrid = [];\n    async function createGUI() {\n        // get grid controls and set pointer blocker to false\n        for (let grid of gui.texture.getControlsByType(\"Grid\")) {\n            grid.isPointerBlocker = false;\n            if (grid.name === \"layout\") {\n                gui.layoutGrid = grid;\n            }\n            if (grid.name === \"layers\") {\n                gui.layersGrid = grid;\n            }\n            if (grid.name === \"sliders\") {\n                gui.slidersGrid = grid;\n                gui.slidersGrid.isVisible = false;\n            }\n            if (grid.name === \"contentButtons\") {\n                gui.contentButtonsGrid = grid;\n                gui.contentButtonsGrid.isVisible = false;\n            }\n            if (grid.name.split(\"_\")[2] === \"uiGrid\") {\n                gui.layerUiGrid.push(grid);\n            }\n        }\n        \n        // get rectangle controls and set pointer blocker to false\n        for (let rect of gui.texture.getControlsByType(\"Rectangle\")) {\n            rect.isPointerBlocker = false;\n        }\n\n        // get slider title and slider controls and set alignment on text for all avalable parameters\n        gui.slider_horizontal_title = gui.texture.getControlByName(\"slider_horizontal_title\");\n        gui.slider_horizontal_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_horizontal = gui.texture.getControlByName(\"slider_horizontal\");\n        gui.slider_horizontal.onValueChangedObservable.add(function(value) {\n            layers[currentLayer].horizontal = value;\n            if (activeUpdate) {\n                updateimprint();\n            }\n        });\n\n        gui.slider_vertical_title = gui.texture.getControlByName(\"slider_vertical_title\");\n        gui.slider_vertical_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_vertical = gui.texture.getControlByName(\"slider_vertical\");\n        gui.slider_vertical.onValueChangedObservable.add(function(value) {\n            layers[currentLayer].vertical = value;\n            if (activeUpdate) {\n                updateimprint();\n            }\n        });\n\n        gui.slider_size_title = gui.texture.getControlByName(\"slider_size_title\");\n        gui.slider_size_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_size = gui.texture.getControlByName(\"slider_size\");\n        gui.slider_size.onValueChangedObservable.add(function(value) {\n            layers[currentLayer].size = value;\n            if (activeUpdate) {\n                updateimprint();\n            }\n        });\n\n        gui.slider_width_title = gui.texture.getControlByName(\"slider_width_title\");\n        gui.slider_width_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_width = gui.texture.getControlByName(\"slider_width\");\n        gui.slider_width.onValueChangedObservable.add(function(value) {\n            layers[currentLayer].width = value;\n            if (activeUpdate) {\n                updateimprint();\n            }\n        });\n\n        gui.slider_height_title = gui.texture.getControlByName(\"slider_height_title\");\n        gui.slider_height_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_height = gui.texture.getControlByName(\"slider_height\");\n        gui.slider_height.onValueChangedObservable.add(function(value) {\n            if (layers[currentLayer].rectangle) {\n                layers[currentLayer].height = value;\n                if (activeUpdate) {\n                    updateimprint();\n                }\n            }\n            else {\n                layers[currentLayer].rotation = value;\n                if (activeUpdate) {\n                    updateimprint();\n                }\n            }\n        });\n\n        gui.slider_rotation_title = gui.texture.getControlByName(\"slider_rotation_title\");\n        gui.slider_rotation_title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;\n        gui.slider_rotation = gui.texture.getControlByName(\"slider_rotation\");\n        gui.slider_rotation.onValueChangedObservable.add(function(value) {\n            layers[currentLayer].rotation = value;\n            if (activeUpdate) {\n                updateimprint();\n            }\n        });\n\n        // get layers backgrounds\n        gui.layerBG = [];\n        for (let rect of gui.texture.getControlsByType(\"Rectangle\")) {\n            if (rect.name.split(\"_\")[2] === \"bg\") {\n                gui.layerBG.push(rect);\n            }\n        }\n\n        // assign icons and actions to buttons\n        gui.buttons = gui.texture.getControlsByType(\"Button\");\n        for (let button of gui.buttons) {\n            button.width = \"100%\";\n            button.fixedRatio = 1.0;\n            if (button._children[0] !== undefined) {\n                button._children[0].height = \"100%\";\n                button._children[0].fixedRatio = 1.0;\n            }\n            if (button.name.split(\"_\")[2] === \"upButton\") {\n                button._children[0].source = assets.moveUpIcon.url;\n                button.isVisible = true;\n                button.onPointerClickObservable.add(function() {\n                    moveLayer(parseInt(button.name.split(\"_\")[1]), \"up\");\n                    currentLayer = undefined;\n                    updateActiveLayer();\n                });\n            }\n            if (button.name.split(\"_\")[2] === \"downButton\") {\n                button._children[0].source = assets.moveDownIcon.url;\n                button.isVisible = true;\n                button.onPointerClickObservable.add(function() {\n                    moveLayer(parseInt(button.name.split(\"_\")[1]), \"down\");\n                    currentLayer = undefined;\n                    updateActiveLayer();\n                });\n            }\n            if (button.name.split(\"_\")[2] === \"insertButton\") {\n                button._children[0].source = assets.addIcon.url;\n                button.onPointerClickObservable.add(function() {\n                    currentLayer = parseInt(button.name.split(\"_\")[1]);\n                    chooseContent();\n                });\n            }\n            if (button.name.split(\"_\")[2] === \"deleteButton\") {\n                button._children[0].source = assets.cancelIcon.url;\n                button.isVisible = true;\n                button.onPointerClickObservable.add(function() {\n                    unloadLayerContentUI(parseInt(button.name.split(\"_\")[1]));\n                    removeLayerGraphic(parseInt(button.name.split(\"_\")[1]))\n                });\n            }\n            if (button.name.split(\"_\")[2] === \"selectButton\") {\n                button.fixedRatio = 0.0;\n                button.onPointerClickObservable.add(function() {\n                    currentLayer = parseInt(button.name.split(\"_\")[1]);\n                    updateActiveLayer();\n                });\n                button.isVisible = true;\n            }\n        }\n\n        // get layer textblocks and assign them to the layer array in the correct order\n        gui.layerContentNames = [];\n        for (let textBlock of gui.texture.getControlsByType(\"TextBlock\")) {\n            if (textBlock.name.split(\"_\")[2] === \"contentName\") {\n                gui.layerContentNames.push(textBlock);\n                textBlock.isVisible = true;\n            }\n        }\n    }\n\n    // update sliders panel with the correct controls for the layer\n    function updateGUI(layer) {\n        if (layer !== undefined) {\n        }\n        if (currentLayer !== undefined) {\n            // disable update for dynamic texture when setting sliders due to layer change\n            activeUpdate = false;\n            gui.slidersGrid.isVisible = true;\n\n            // update sliders for rectangle content parameters\n            if (layer.rectangle && layer.graphic === undefined) {\n                gui.slider_horizontal.minimum = -1;\n                gui.slider_horizontal.maximum = 1;\n                gui.slider_horizontal.value = layer.horizontal;\n                \n                gui.slider_vertical.minimum = -1;\n                gui.slider_vertical.maximum = 1;\n                gui.slider_vertical.value = layer.vertical;\n    \n                gui.slider_size_title.isVisible = false;\n                gui.slider_size.isVisible = false;\n\n                gui.slider_width_title.isVisible = true;\n                gui.slider_width.isVisible = true;\n                gui.slider_width.minimum = 0;\n                gui.slider_width.maximum = 2;\n                gui.slider_width.value = layer.width;\n    \n                gui.slider_height_title.isVisible = true;\n                gui.slider_height.isVisible = true;\n                gui.slider_height.minimum = 0;\n                gui.slider_height.maximum = 2;\n                gui.slider_height.value = layer.height;\n    \n                gui.slidersGrid.removeControl(gui.slider_rotation_title)\n                gui.slidersGrid.addControl(gui.slider_rotation_title, 5, 0)\n                gui.slidersGrid.removeControl(gui.slider_rotation)\n                gui.slidersGrid.addControl(gui.slider_rotation, 5, 1)\n                gui.slider_rotation_title.isVisible = true;\n                gui.slider_rotation.isVisible = true;\n                gui.slider_rotation.minimum = -Math.PI;\n                gui.slider_rotation.maximum = Math.PI;\n                gui.slider_rotation.value = layer.rotation;\n            }\n            // update sliders for image content parameters\n            else {\n                gui.slider_horizontal.minimum = -2;\n                gui.slider_horizontal.maximum = 2;\n                gui.slider_horizontal.value = layer.horizontal;\n    \n                gui.slider_vertical.minimum = -2;\n                gui.slider_vertical.maximum = 2;\n                gui.slider_vertical.value = layer.vertical;\n    \n                gui.slider_size_title.isVisible = true;\n                gui.slider_size.isVisible = true;\n                gui.slider_size.minimum = 0;\n                gui.slider_size.maximum = 2048;\n                gui.slider_size.value = layer.size;\n\n                gui.slider_width_title.isVisible = false;\n                gui.slider_width.isVisible = false;\n                gui.slider_height_title.isVisible = false;\n                gui.slider_height.isVisible = false;\n\n                gui.slidersGrid.removeControl(gui.slider_rotation_title)\n                gui.slidersGrid.addControl(gui.slider_rotation_title, 4, 0)\n                gui.slidersGrid.removeControl(gui.slider_rotation)\n                gui.slidersGrid.addControl(gui.slider_rotation, 4, 1)\n                gui.slider_rotation.minimum = -Math.PI;\n                gui.slider_rotation.maximum = Math.PI;\n                gui.slider_rotation.value = layer.rotation;\n            }\n            activeUpdate = true;\n            }        \n    }\n\n    // scene logic\n    initScene();\n    await loadAssets();\n\n    return scene;\n};",
  "created_at": "2025-08-07T23:52:18.201590",
  "updated_at": "2025-08-07T23:52:18.201606"
}