{
  "name": "waves form method",
  "type": "map",
  "code": "var createScene = async function () {\n    // This creates a basic Babylon Scene object (non-mesh)\n    var scene = new BABYLON.Scene(engine);\n\n    const server = \"/external-import/\";\n\n    // create camera and lights for scene\n    const env = {};\n    const camera = {};\n    const clearColor = new BABYLON.Color3.FromInts(56, 56, 58);\n    async function initScene() {\n        // color of scene when no skybox present\n        scene.clearColor = clearColor;\n\n        // standard ArcRotate camera\n        camera.main = new BABYLON.ArcRotateCamera(\"camera\", 0.728, 1.345, 35, new BABYLON.Vector3(0.32, -3.12, 0.26), scene);\n        camera.main.minZ = 0.1;\n        camera.main.wheelDeltaPercentage = 0.1;\n        camera.main.attachControl(canvas, true);\n\n        // add in IBL with linked environment\n        env.lighting = BABYLON.CubeTexture.CreateFromPrefilteredData(server + \"server/studio.env\", scene);\n        env.lighting.name = \"studioIBL\";\n        env.lighting.gammaSpace = false;\n        env.lighting.rotationY = 2.3667;\n        scene.environmentTexture = env.lighting;\n        scene.environmentIntensity = 1.0;\n    }   \n\n    // create buttons\n    let createButton = function(name, gridPos, value, container) {\n        let button = BABYLON.GUI.Button.CreateSimpleButton(\"button\", name);\n        button.paddingTop = \"30px\";\n        button.width = 0.7;\n        button.height = \"80px\";\n        button.color = \"white\";\n        button.thickness = 1;\n        button.background = \"transparent\";\n        button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n        button.onPointerDownObservable.add(function() {\n            meshesMats.straightWave.value = value;\n        });\n        container.addControl(button, gridPos.x, gridPos.y);  \n    }\n\n    // load or create meshes in scene\n    const meshes = {};\n    const meshParams = {};\n    async function loadMeshes() {\n        // load bars mesh\n        meshes.barsAsset = await BABYLON.SceneLoader.AppendAsync(server + \"server/\", \"bars.glb\", scene).then((results) => {\n            for (let mesh of results.meshes) {\n                if (mesh.name === \"bars\") {\n                    meshes.bars = mesh;\n                    meshParams.minX = mesh.getBoundingInfo().boundingBox.minimumWorld.x;\n                    meshParams.maxX = mesh.getBoundingInfo().boundingBox.maximumWorld.x;\n                    meshParams.minZ = mesh.getBoundingInfo().boundingBox.minimumWorld.z;\n                    meshParams.maxZ = mesh.getBoundingInfo().boundingBox.maximumWorld.z;\n                }\n            }\n        });  \n    }\n\n    // create materials for scene meshes\n    // ignore textures embedded in shader when loading\n    BABYLON.NodeMaterial.IgnoreTexturesAtLoadTime = true;\n    const meshesMats = {};\n    const textures = {};\n    async function createMaterials() {\n        // load texture for bar color randomization\n        textures.barColor = new BABYLON.Texture(server + \"server/barsColor_randomValue.png\", scene, false, false, BABYLON.Texture.NEAREST_SAMPLINGMODE);\n        textures.barColor.wrapU = textures.barColor.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n\n        // node material for bars\n        meshesMats.bars = new BABYLON.NodeMaterial(\"barsMat\", scene);\n        await meshesMats.bars.loadAsync(server + \"server/bars.json\");\n        meshesMats.bars.build(false);\n        meshesMats.bars.transparencyMode = 0;\n\n        // set bars material parameters\n        meshesMats.bars.getBlockByName(\"baseColorTex\").texture = textures.barColor;\n        meshesMats.bars.getBlockByName(\"minX\").value = meshParams.minX;\n        meshesMats.bars.getBlockByName(\"maxX\").value = meshParams.maxX;\n        meshesMats.bars.getBlockByName(\"minZ\").value = meshParams.minZ;\n        meshesMats.bars.getBlockByName(\"maxZ\").value = meshParams.maxZ;\n        meshesMats.straightWave = meshesMats.bars.getBlockByName(\"straightWave\");\n\n        // assign material to bars\n        meshes.bars.material = meshesMats.bars;\n    }\n\n    let rotation = -1;\n    scene.onBeforeCameraRenderObservable.add(() => {\n        // animate camera rotation\n        rotation += 0.008;\n        camera.main.alpha = Math.sin(rotation) * 0.00025 + camera.main.alpha;\n    });\n\n    // create UI\n    const ui = {};\n    function createUI() {\n        // UI grid\n        ui.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\n        ui.grid = new BABYLON.GUI.Grid(\"grid\");\n        ui.grid.addRowDefinition(1.0);\n        ui.grid.addColumnDefinition(0.5);\n        ui.grid.addColumnDefinition(0.5);\n        ui.grid.height = 0.15;\n        ui.grid.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;\n        ui.grid.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;\n        ui.advancedTexture.addControl(ui.grid);\n\n        // create buttons\n        createButton(\"Straight Wave\", new BABYLON.Vector2(0, 0), 1.0, ui.grid);\n        createButton(\"Circular Wave\", new BABYLON.Vector2(0, 1), 0.0, ui.grid);    \n    }           \n    \n    // scene logic\n    initScene();\n    await loadMeshes();\n    await createMaterials();\n    createUI();\n\n    return scene;\n};",
  "created_at": "2025-08-08T00:58:50.157120",
  "updated_at": "2025-08-08T00:58:50.157139"
}