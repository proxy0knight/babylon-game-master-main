{
  "name": "Auto sound animation",
  "type": "map",
  "code": "var createScene = function () {\n    var scene = new BABYLON.Scene(engine);\n\n    // Lights\n    var light0 = new BABYLON.DirectionalLight(\"Omni\", new BABYLON.Vector3(-2, -5, 2), scene);\n    var light1 = new BABYLON.PointLight(\"Omni\", new BABYLON.Vector3(2, -5, -2), scene);\n\n    // Need a free camera for collisions\n    var camera = new BABYLON.FreeCamera(\"FreeCamera\", new BABYLON.Vector3(15, -8, -40), scene);\n    camera.attachControl(canvas, true);\n\n    //Ground\n    var ground = BABYLON.Mesh.CreatePlane(\"ground\", 400.0, scene);\n    ground.material = new BABYLON.StandardMaterial(\"groundMat\", scene);\n    ground.material.diffuseColor = new BABYLON.Color3(1, 1, 1);\n    ground.material.backFaceCulling = false;\n    ground.position = new BABYLON.Vector3(5, -10, -15);\n    ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);\n\n    // Create and load the sound async\n    var music = new BABYLON.Sound(\"001\", \"sounds/001.mp3\", scene, null, { loop: true, autoplay: true });\n\n\tvar myAnalyser = new BABYLON.Analyser(scene);\n\tBABYLON.Engine.audioEngine.connectToAnalyser(myAnalyser);\n\tmyAnalyser.FFT_SIZE = 32;\n\tmyAnalyser.SMOOTHING = 0.9;\n\t\n\tvar spatialBoxArray = [];\n\tvar spatialBox;\n\tvar color;\n\t\n\tfor (var index = 0; index < myAnalyser.FFT_SIZE / 2; index++) {\n\t    spatialBox = BABYLON.Mesh.CreateBox(\"sb\" + index, 2, scene);\n\t    spatialBox.position = new BABYLON.Vector3(index * 2, 0, 0);\n\t    spatialBox.material = new BABYLON.StandardMaterial(\"sbm\" + index, scene);\n\t    color = hsvToRgb(index / (myAnalyser.FFT_SIZE) / 2 * 360, 100, 50),\n\t    spatialBox.material.diffuseColor = new BABYLON.Color3(color.r, color.g, color.b);\n\t    spatialBoxArray.push(spatialBox);\n\t}\n\t\n\tscene.registerBeforeRender(function () {\n\t    var workingArray = myAnalyser.getByteFrequencyData();\n\t\n\t    for (var i = 0; i < myAnalyser.getFrequencyBinCount() ; i++) {\n\t        spatialBoxArray[i].scaling.y =  workingArray[i] / 32;\n\t    }\n\t});\n\n    //Set gravity for the scene (G force like, on Y-axis)\n    scene.gravity = new BABYLON.Vector3(0, -0.9, 0);\n\n    // Enable Collisions\n    scene.collisionsEnabled = true;\n\n    //Then apply collisions and gravity to the active camera\n    camera.checkCollisions = true;\n    camera.applyGravity = true;\n\n    //Set the ellipsoid around the camera (e.g. your player's size)\n    camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);\n\n    //finally, say which mesh will be collisionable\n    ground.checkCollisions = true;\n\t\n\tfunction hsvToRgb(h, s, v) {\n    \tvar r, g, b;\n    \tvar i;\n    \tvar f, p, q, t;\n\n    \th = Math.max(0, Math.min(360, h));\n    \ts = Math.max(0, Math.min(100, s));\n    \tv = Math.max(0, Math.min(100, v));\n\n    \ts /= 100;\n    \tv /= 100;\n\n    \tif(s == 0) {\n        \t\tr = g = b = v;\n        \t\treturn [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n        \t}\n\n    \th /= 60; // sector 0 to 5\n    \ti = Math.floor(h);\n    \tf = h - i; // factorial part of h\n    \tp = v * (1 - s);\n    \tq = v * (1 - s * f);\n    \tt = v * (1 - s * (1 - f));\n\n    \tswitch(i) {\n    \t\tcase 0:\n    \t\t\tr = v;\n    \t\t\tg = t;\n    \t\t\tb = p;\n    \t\t\tbreak;\n    \t\tcase 1:\n    \t\t\tr = q;\n    \t\t\tg = v;\n    \t\t\tb = p;\n    \t\t\tbreak;\n    \t\tcase 2:\n    \t\t\tr = p;\n    \t\t\tg = v;\n    \t\t\tb = t;\n    \t\t\tbreak;\n    \t\tcase 3:\n    \t\t\tr = p;\n    \t\t\tg = q;\n    \t\t\tb = v;\n    \t\t\tbreak;\n    \t\tcase 4:\n    \t\t\tr = t;\n    \t\t\tg = p;\n    \t\t\tb = v;\n    \t\t\tbreak;\n    \t\tdefault: // case 5:\n    \t\t\tr = v;\n    \t\t\tg = p;\n    \t\t\tb = q;\n    \t}\n    \treturn {r: r, g: g, b: b};\n\t}\n\n    return scene;\n};",
  "created_at": "2025-07-29T20:30:29.464081",
  "updated_at": "2025-07-29T20:30:29.464445"
}